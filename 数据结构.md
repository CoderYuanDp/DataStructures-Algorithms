## 数据结构
- 数组 Array
- 栈 Stack
- 链表 Linked-List
- 图 Graph
- 散列图 Hash
- 队列 Queue
- 堆 Heap
- 树 Tree

### 数组
数据的集合
- push 向数组末尾添加新元素
- pop 删除数组最后一项
- shift 删除数组第一项
- unshift 向数组首位添加一项
- splice 对数组增删改
- join 拼接
- slice 按照条件查找其中部分元素
- fill 填充数组
- filter 过滤
- concat 连接两个或多个数组
- indexOf 当前值在数组出现的第一次的位置
- lastIndexOf 出现最后一次的位置

- every 判断数组中每一项是否满足条件
- some 是否有满足条件的项
- includes 判断数组是否包含一个指定的值
- sort 排顺序
- reverse 倒序
- forEach 遍历
- map 遍历并返回新数组
- copyWithin 从数组指定位置拷贝元素到数组另一个位置
- find 返回匹配的值
- findIndex 返回匹配位置索引
- findLast 返回匹配的最后一个位置索引
- reduce 迭代数组
- toLocalString、toString 数组转字符串
- flat、 flatMap 扁平化数组
- entries、keys、values 遍历

- 迭代器
```javascript
let arr = [1, 2, 3, 4, 5]
const ite = arr[Symbol.iterator] //迭代器接口
ite.next() // { value: 1, done: false }
```

### 栈
又名堆栈
一种受运算限制的线性表，限定在表尾（栈顶）进行插入和删除操作的线性表，另一端为栈底。
**后进先出Last IN First OUT(FLFO)**
```javascript
  // push 添加元素到栈顶
  // pop 出站
  // peek 返回栈顶
  // isEmpty()
  // clear()
  // size()
  // toString()
  class Stack {
    // constructor() {
    //   this.items = []
    // }
    // _items = []  // _表示私有属性
    #items = [] // es13新特性，类私有属性
    pop(data) {
      return this.#items.pop(data)
    }
    push(data) {
      this.#items.push(data)
    }
    peek() { // 栈顶
      return this.#items.at(-1)
    }
    isEmpty() {
      return this.#items.length === 0
    }
    size() {
      return this.#items.length
    }
    clear() {
      this.#items = []
    }
    toString() {
      return this.#items.join(' ')
    }
  }
let stack = new Stack()

// 应用，转换进制
function convert(decNumber, base) {
  let remStack = new Stack()
  let number = decNumber
  let string = ''
  const baseString = '0123456789ABCDEF'
  while(number > 0) {
    remStack.push(number%base)
    number = Math.floor(number/base)
  }
  while(!remStack.isEmpty()) {
    string += baseString[remStack.pop()]
  }
  return string
}
```

### 队列
一种特殊的线性表，只允许在表的前部(队头)进行删除，而在表的后端(队尾)进行插入
先进先出First IN First Out（FIFO）
事件循环，宏任务可以有多个队列，微任务只有一个
```javascript
class Queue {
  #items = {}
  #lowCount = 0  // 队头索引
  #count = 0
  delqueue() {
    if(this.isEmpty()) {
      return undefined
    }
    let res = this.#items[this.#lowCount];
    delete this.#items[this.#lowCount]
    this.#lowCount++
    return res
  }
  enqueue(data) {
    this.#items.[this.#count] = data
    this.#count++
  }
  front() {
    return this.#items[this.#lowCount]
  }
  isEmpty() {
    return this.size() === 0
  }
  size() {
    return this.#count - this.#lowCount
  }
  clear() {
    this.#items = {}
    this.#lowCount = 0
    this.#count = 0
  }
  toString() {
    return this.#items.values.join(' ') || ''
  }
}
```

#### 双端队列
两端都可以插入|删除元素
```javascript
class DeQueue {
  #items = {}
  #lowCount = 0
  #count = 0
  removeFront() {
    if(this.isEmpty()) {
      return  undefined
    }
    let res = this.#items[this.#lowCount]
    delete this.#items[this.#lowCount]
    this.#lowCount++
    return res
  }

  addBack(data) {
    this.#items[this.#count] = data
    this.#count++
  }

  addFront(data) {
    if(this.isEmpty()) {
      this.addBack(data)
    }else if(this.#lowCount > 0) {
      this.#lowCount--
      this.#items[this.#lowCount] = data
    }else if(this.#lowCount === 0) {
      for(let i = 0; i < this.#count; i++) {
        this.#items[i+1] = this.#items[i]
      }
      this.#items[0] = data
      this.#count++
    }

    removeBack() {
      if(this.isEmpty()) {
        return
      }
      this.#count--
      let res = this.#items[this.#count]
      delete this.#items[this.#count]
      return res
    }

    peekFront() {
      return this.#items[this.#lowCount]
    }

    peekBack() {
      if(this.isEmpty()) {
        return
      }
      return this.#items[this.#count-1]
    }

    isEmpty() {
      return this.size() === 0
    }

    size() {
      return this.#count - this.#lowCount
    }

    clear() {
      this.#items = {}
      this.#lowCount = 0
      this.#count = 0
    }
  }
}
```

### 单链表
```javascript
class Node {
  constructor(ele) {
    this.element = ele
    this.next = null
  }
}

class LinkedList {
  constructor() {
    this.count = 0
    this.head = null

    push(ele) {
      let node = new Node(ele)

      if(this.head === null) {
        this.head = node
      }else {
        // 找到没有后继的node
        let current = this.head
        while(current.next !== null) {
          current = current.next
        }

        current.next = node
      }

      this.count++
    }

    removeAt(index) {
      if(index >= 0 && index < this.count) {
        let current = this.head
        if(index === 0) {
          this.head = this.head.next
        }else {
          let previous = this.getNodeAT(index-1)
          current = previous.next
          previous.next = current.next
        }
        this.count--
        return current.element
      }
      
      return
    }

    getNodeAt(index) {
      if(index >= 0 && index < this.count) {
        let node = this.head

        for(let i = 0; i < index; i++) {
          node = node.next
        }
        
        return node
      }
      return
    }

    equalFn(a, b) {
      return a === b
    }

    indexOf(ele) {
      let current = this.head
      for(let i = 0; i < this.count; i++) {
        if(this.equalFn(current.element, ele)) {
          return i
        }
        current = current.next
      }
      return -1
    }

    remove(ele) {
      const index = this.indexOf(ele)
      this.removeAt(index)
    }

    insert(ele, index) {
      if(index >= 0; index <= this.count) {
        const node = new Node(ele)
        if(index === 0) {
          const current = this.head
          node.next = current
          this.head = node
        }else {
          const previous = this.getNodeAt(index-1)
          const current = previous.next

          node.next = current
          previous.next = node
        }

        this.count++
        return true
      }
      return false
    }

    isEmpty() {
      return this.size() === 0
    }

    size() {
      return this.count
    }

    getHead() {
      return this.head
    }
  }
}

let list = new LinkedList()
```

#### 双向链表
有两个指针，一个指向前一个节点地址（前驱prev），一个指向后一个节点地址（后继next）
```javascript
class Node {
  constructor(ele) {
    this.element = ele
    this.next = null
  }
}

class DoublyNode extends Node {
  constructor(ele) {
    super(ele)
    this.prev = null
  }
}

class LinkedList {

}

class DoublyLikedList extends LinkedList {
  constructor() {
    super()
    this.tail = null
  }

  push(element) {
    const node = new DoublyNode(element)
    if(this.head === null) {
      this.head = node
      this.tail = node
    }else {
      this.tail.next = node
      node.prev = this.tail
      this.tail = node
    }
    this.count++
  }

  insert(element, index) {
    if(index >= 0 && index <= this.count ) {
      const node = new DoublyNode(element)
      let current = this.head
      if(index === 0) {
        if(this.head === null){
          this.head = node
          this.tail = node
        }else{
            node.next = this.head
            this.head.prev= node
            this.head = node
        }
      }else if(index === this.count) {
        current = this.tail
        current.next = node
        node.prev = current
        this.tail = node
      }else {
        const previous = this.getNodeAt(index-1)
        current = previous.next
        node.next = current
        current.prev = node
        previous.next = node
        node.prev = previous
      }

      this.count++
      return true
    }
     return false
  }

  removeAt(index) {
    if(index >= 0 && index < this.count)
      let current = this.head
      if(index === 0) {
        this.head = current.next
        if(this.count === 1) {
          this.tail = null
        }else {
          this.head.prev = undefined
        }
      }else if(index === this.count-1) {
        current = this.tail
        this.tail = current.prev
        this.tail.next = undefined
      }else {
        let previous = this.getNodeAt(index-1)
        current = previous.next
        previous.next = current.next
        current.next.prev = previous
      }
      this.count--
      return current.element
    }
    return
  }

  getHead() {
    return this.head
  }

  getTail() {
    return this.tail
  }
}
```

#### 循环链表
```javascript
class LinkedList {

}

class CirularLinkedList extends LinkedList {
  costructor() {
    super()
  }

  push(element) {
    const node = new Node(element)
    let current
    if(this.head === null) {
      this.head = node
    }else {
      current = this.getNodeAt(this.size() - 1)
      current.next = node
    }

    node.next = this.head
    this.count++
  }

  insert(element, index) {
    if(index >= 0 && index <= this.count) {
      const node = new Node(element)
      let current = this.head
      if(index === 0) {
        if(this.head === null) {
          this.head = node
          node.next = this.head
        }else {
          node.next = current
          this.head = node
          current = this.getNodeAt(this.size() - 1)
          this.head = node
          current.next = this.head
        }
      }else {
        const previous = this.getNodeAt(index-1)
        node.next = previous.next
        previous.next = node
      }
      this.count++
      return true
    }
    return false
  }

  removeAt() {
    if(index >= 0 && index < this.count) {
      let current = this.head
      if(index === 0){ 
        if(this.size() === 1){
          this.head = undefined
        }else{
          let last = this.getNodeAt(this.size() - 1)
          this.head = this.head.next
          last.next = this.head
        }
      }else {
        const previous = this.getNodeAt(inedx - 1)
        current = previous.next
        previous.next = current.next
      }
      this.count--
      return current.element
    }
    return
}
```

### 集合
由一组无序且唯一（不能重复）的项组成。
```javascript
class MySet {
  constructor() {
    this.items = {}
  }

  add(element) {
    if(!this.has(element)) {
      this.items[element] = element
      return true
    }
    return false
  }

  delete(element) {
    if(this.has(element)) {
      delete this.items[element]
      return true
    }
    return false
  }

  has(element) {
    return element in this.items
  }

  clear() {
    this.items = {}
  }

  size() {
    return Object.keys(this.items).length
  }

  values() {
    return Object.values(this.items)
  }
}

```





























